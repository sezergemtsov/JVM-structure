# JVM-structure with VisualVM

---

## Programm

Программа состоит из двух частей. В первой создаются зеркала классов последовательно из трех пакетов. Данная часть программы предназначена для загрузки метаспейса. 
Параллельно загрузке классов происходит выделение памяти в куче для инициализации статических переменных ссылочных типов, поэтому происходит небольшой скачек на графике хипа.
Вторая часть последовательно создает 3 списка объектов которые содержат внутри только значение типа Integer. Так как списки состоят из обьектов ссылочного типа в данной части в основном загружается куча.

## Metaspace

Как упоминалось ранее данный раздел загружен первой половиной программы. В консоли выводятся метки фрейма вызова метода в котором создается зеркало переданного репозитория,
а также выводится информация по количеству классов в данном репозитории которые нужно было обработать и которые выгружались в metaspace.

3 скачка на графике памяти metaspace соответсвуют поочередному вызову этого метода с разными репозиториями в аргументах
После подгрузки классов ничего интересного в metaspace не происходит

![alt text](https://github.com/sezergemtsov/JVM-structure/blob/main/JVM%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20VisualVM/MetaM.png)

## Heap

Для кучи ситуация немного отличается. Хоть в первой части программы напрямую в коде мы не создаем данные которые должны были бы сюда попадать самостоятельно, тем не менее
подгружаемые классы имеют статические поля которые необхадимо инициализировать и которые могут содержать ссылочные типы данных для которых место в хипе выделять нужно. 
Именно с этим связан небольшой скачек в районе первых 3х отметок, в ходе которых мы максимально нагружаем metaspace.
Однако фреймы метода закрываются после всех трех вызовов, и программно поступает команда усыпить потоки для паузы. Так как вне фреймов ссылки на инициализированные поля
теряют свою актуальность они помечаются для сбощика мусора как кандидаты на удаление. Сам сборщик решает сработать в ~12:34 где то после 2го вызова метода загрузки зеркал классов.
При этом видит что хип почти не используется и уменьшает выделенное на него пространство.

Далее начинается вторая часть программы по обработке списков из объектов. Как и говорилось ранее, так как объекты ссылочного типа, а также содержат внутри поля типа Integer,
для всего этогу нужно выделять место в хипе. Ниже на графике мы можем наблюдать три итерации с прерываниями в которых создаются динамические массивы объектов которые заполняют хип. Так же видно что по мере заполнения динамически выделяется память хипа, которой начинает не хватать для всех объектов.
Так как динамический массив инициализирован во фрейме main ссылки на создаваемые объекты остаются релевантными до завершения программы, а сборщик мусора более не срабатывает.

![alt text](https://github.com/sezergemtsov/JVM-structure/blob/main/JVM%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20VisualVM/HeapM.png)
